
# This R Energy Measurement using RAPL Works but it requires SUDO

#' Helper: Read a numeric value from a sysfs file
read_sysfs_val <- function(filepath) {
  if (!file.exists(filepath)) return(NA_real_)
  # Try to open the file connection first to catch permission issues more directly
  con <- try(file(filepath, "r"), silent = TRUE)
  if (inherits(con, "try-error")) {
    # Warning will be generated by file() itself if not fully silenced by R options
    # or if the calling context doesn't suppress it.
    # We don't add another warning here to avoid duplication.
    return(NA_real_)
  }
  on.exit(close(con), add = TRUE)
  
  tryCatch(as.numeric(readLines(con, n = 1, warn = FALSE)),
           error = function(e) NA_real_,
           warning = function(w) NA_real_) # Catch as.numeric warnings too
}

#' Start a simplified RAPL energy trace.
#' Discovers domains under /sys/class/powercap/[VENDOR]-rapl/subsystem/
#' where [VENDOR] is typically 'intel'.
#' @return A list with 'start_time_POSIXct', 'initial_readings_uJ' (named list),
#'         and 'domain_details' (named list with 'name_from_file', 'max_energy_uj').
#'         Returns NULL on failure (e.g., path not found, no readable domains).
start_rapl_trace_simple <- function(rapl_vendor_dir_name = "intel-rapl") { # Default to intel
  if (Sys.info()["sysname"] != "Linux") {
    # message("RAPL tracing only on Linux.") # Kept for package context
    return(NULL)
  }
  
  base_powercap_path <- "/sys/class/powercap/"
  # Construct the specific path as per Python example's default
  # e.g., /sys/class/powercap/intel-rapl/subsystem
  rapl_subsystem_path <- file.path(base_powercap_path, rapl_vendor_dir_name, "subsystem")
  
  if (!dir.exists(rapl_subsystem_path)) {
    message(paste("RAPL subsystem path not found:", rapl_subsystem_path,
                  "\nThis system may not use this RAPL structure, or RAPL is not available/configured.",
                  "\n(Based on Python example, expected RAPL controllers like 'intel-rapl:0' inside this path)"))
    return(NULL)
  }
  
  all_domains_config <- list()
  
  # List entries under the subsystem_path and filter for RAPL controller-like names (containing ':')
  potential_controller_names <- list.files(rapl_subsystem_path, full.names = FALSE)
  # Python code uses: list(filter(lambda x: ":" in x, os.listdir(self._lin_rapl_dir)))
  # R equivalent for the filter:
  rapl_controller_names_in_subsystem <- potential_controller_names[grepl(":", potential_controller_names, fixed = TRUE)]
  
  if (length(rapl_controller_names_in_subsystem) == 0) {
    message(paste("No RAPL controller directories (e.g., 'intel-rapl:0', 'intel-rapl:0:0') found inside:", rapl_subsystem_path))
    return(NULL)
  }
  
  for (controller_name in rapl_controller_names_in_subsystem) {
    zone_path <- file.path(rapl_subsystem_path, controller_name) # Full path to the controller dir
    
    # This 'zone_path' is now what we consider a RAPL endpoint
    # e.g., /sys/class/powercap/intel-rapl/subsystem/intel-rapl:0
    # or /sys/class/powercap/intel-rapl/subsystem/intel-rapl:0:0
    
    energy_file <- file.path(zone_path, "energy_uj")
    name_file <- file.path(zone_path, "name")
    
    if (file.exists(energy_file) && file.exists(name_file)) { # Check existence before trying to read
      raw_name <- tryCatch(trimws(readLines(name_file, n = 1, warn = FALSE)),
                           error = function(e) basename(zone_path)) # Fallback
      
      # Create a unique ID from the relative path under /sys/class/powercap/ and the raw_name
      relative_path_id <- gsub("/", "_", sub(paste0(base_powercap_path,"/?"), "", zone_path))
      domain_id_candidate <- paste0(relative_path_id, "_", gsub("[^a-zA-Z0-9_]", "", raw_name))
      
      current_keys <- names(all_domains_config)
      if(domain_id_candidate %in% current_keys) {
        domain_id <- make.unique(c(current_keys, domain_id_candidate))[length(current_keys) + 1]
      } else {
        domain_id <- domain_id_candidate
      }
      
      all_domains_config[[domain_id]] <- list(
        path_to_energy_uj = energy_file,
        name_from_file = raw_name,
        max_energy_uj = read_sysfs_val(file.path(zone_path, "max_energy_range_uj"))
      )
    }
  } # End loop
  
  if (length(all_domains_config) == 0) {
    message(paste("No valid RAPL endpoints with energy_uj/name files found in:", rapl_subsystem_path))
    return(NULL)
  }
  
  initial_readings <- sapply(all_domains_config, function(d) read_sysfs_val(d$path_to_energy_uj), USE.NAMES = TRUE)
  
  valid_domains_idx <- !is.na(initial_readings)
  if(sum(valid_domains_idx) == 0) {
    message(paste("Could not read any RAPL energy counters from discovered paths under", rapl_subsystem_path,
                  "\nThis is often due to insufficient permissions. Try running R with 'sudo'."))
    return(NULL)
  }
  
  return(list(
    start_time_POSIXct = Sys.time(),
    initial_readings_uJ = initial_readings[valid_domains_idx],
    domain_details = all_domains_config[valid_domains_idx]
  ))
}

#' Stop a simplified RAPL energy trace and report.
#' (This function's internal logic remains unchanged, only its dependency on start_data)
stop_rapl_trace_simple <- function(start_data) {
  if (is.null(start_data) || !all(c("start_time_POSIXct", "initial_readings_uJ", "domain_details") %in% names(start_data))) {
    # message("Invalid start_data for stop_rapl_trace_simple.") # Optional
    return(NULL)
  }
  end_time <- Sys.time()
  # Use read_sysfs_val for consistency, though it was already robust
  final_readings_uJ <- sapply(start_data$domain_details, function(d) read_sysfs_val(d$path_to_energy_uj), USE.NAMES = TRUE)
  
  duration_s <- as.numeric(difftime(end_time, start_data$start_time_POSIXct, units = "secs"))
  report <- list()
  
  for (domain_id in names(start_data$initial_readings_uJ)) {
    start_uJ <- start_data$initial_readings_uJ[[domain_id]]
    end_uJ <- final_readings_uJ[[domain_id]] # This might be NA if final read fails
    details <- start_data$domain_details[[domain_id]]
    
    energy_J <- NA_real_
    power_W <- NA_real_
    
    if (!is.na(start_uJ) && !is.na(end_uJ)) { # Both start and end must be valid
      delta_uJ <- end_uJ - start_uJ
      if (!is.na(details$max_energy_uj) && details$max_energy_uj > 0 && delta_uJ < 0) {
        delta_uJ <- delta_uJ + details$max_energy_uj
      }
      energy_J <- delta_uJ / 1e6
      power_W <- if (duration_s > 1e-9) energy_J / duration_s else NA_real_
    } # else: if end_uJ is NA, energy_J and power_W remain NA (good)
    
    report[[domain_id]] <- list(
      original_name = details$name_from_file,
      energy_J = energy_J,
      power_W = power_W
    )
  }
  return(list(
    start_time = start_data$start_time_POSIXct,
    end_time = end_time,
    duration_s = duration_s,
    report_per_domain = report
  ))
}

#' Wrap an R expression with simplified RAPL snapshot energy tracing.
#' (This function's internal logic remains unchanged, only its dependency on start/stop)
with_rapl_trace_simple <- function(expr, rapl_vendor_dir = "intel-rapl") {
  # Pass the vendor dir to the start function
  initial_trace_state <- start_rapl_trace_simple(rapl_vendor_dir_name = rapl_vendor_dir)
  
  if (is.null(initial_trace_state)) {
    # start_rapl_trace_simple already printed messages
    eval_result <- eval.parent(substitute(expr))
    return(list(result = eval_result, energy_summary = NULL, trace_status = "failed_to_initialize"))
  }
  cat(sprintf("RAPL tracing started for %d domain(s) from '%s/subsystem/'.\n",
              length(initial_trace_state$initial_readings_uJ), rapl_vendor_dir))
  
  eval_outcome <- tryCatch({
    list(result = eval.parent(substitute(expr)), error = NULL)
  }, error = function(e) {
    list(result = NULL, error = e)
  })
  
  final_energy_report <- stop_rapl_trace_simple(initial_trace_state)
  cat("RAPL tracing stopped.\n") # Or this message comes from stop_..._pkg
  
  status_message <- "success"
  if (!is.null(eval_outcome$error)) {
    message("Error occurred during traced expression. Energy data collected up to the error.")
    status_message <- "expression_error"
  }
  if(is.null(final_energy_report) || length(final_energy_report$report_per_domain) == 0) {
    status_message <- paste0(status_message, "_no_valid_energy_report") # More specific
  }
  
  return(list(
    result = eval_outcome$result,
    error_details = eval_outcome$error,
    energy_summary = final_energy_report,
    trace_status = status_message
  ))
}


# Test 
cpu_intensive_task <- function(iterations = 1e7, use_matrix_ops = TRUE) {
  cat(sprintf("Starting CPU-intensive task with %s iterations...\n", format(iterations, scientific = FALSE)))
  
  # Some arithmetic operations
  result <- 0
  for (i in 1:iterations) {
    result <- result + log(sqrt(as.numeric(i) + 0.5)) / (as.numeric(i) + 1.1)
    if (i %% (iterations/10) == 0) {
      cat(".") # Progress indicator
    }
  }
  cat("\n")
  
  if (use_matrix_ops) {
    cat("Performing some matrix operations...\n")
    # Create moderately sized matrices
    mat_size <- min(500, floor(sqrt(iterations/100))) 
    if(mat_size < 10) mat_size <- 10 # ensure a minimum size
    
    A <- matrix(rnorm(mat_size*mat_size), nrow = mat_size)
    B <- matrix(rnorm(mat_size*mat_size), nrow = mat_size)
    
    # Perform a few matrix multiplications
    for(j in 1:3) {
      C <- A %*% B
      A <- B # Swap to do something slightly different next time
      B <- C[,1:mat_size] # Ensure B remains square
    }
    # Add something from matrix ops to the result to ensure it's used
    result <- result + sum(diag(C), na.rm = TRUE) 
  }
  
  cat("CPU-intensive task finished.\n")
  return(result)
}


## TEST FUNCTION
num_iterations <- 8000000 # Example: 8 million iterations

cat("\n--- Starting RAPL Trace for cpu_intensive_task ---\n")
trace_results <- with_rapl_trace_simple({
  # This is the code block that will be monitored
  task_output <- cpu_intensive_task(iterations = num_iterations, use_matrix_ops = TRUE)
  task_output # The wrapper will return this as 'result'
})

print(trace_results)